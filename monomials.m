AttachSpec("../Belyi/Code/spec"); // have to change if Belyi repo is elsewhere
AttachSpec("../BelyiDB/code/spec_database"); // have to change if BelyiDB repo is elsewhere
AttachSpec("../BelyiDB/code/spec_database"); // have to change if BelyiDB repo is elsewhere
//Attach("../Belyi/Code/belyi_main.m"); // have to change if Belyi repo is elsewhere
// includes intrinsic S3Action(tau, phi)
//

intrinsic ReduceRationalFunction(X::Crv, phi::FldFunFracSchElt, P::.) -> Any
  {Given a Belyi map phi defined on a curve X and a prime ideal of the field of definition of X, return the reductions of X and phi mod P}

  // make curve over finite field
  KX := Parent(phi);
  K := BaseRing(X);
  OK := Integers(K);
  FF, res_mp := ResidueClassField(P);
  if Type(X) eq CrvHyp then
    //X := HyperellipticCurveToCurve(X);
    //X_FF := ChangeRing(X, FF); // breaks when over number field
    f, h := HyperellipticPolynomials(X);
    RFF<u> := PolynomialRing(FF);
    cs_f := Coefficients(f);
    cs_h := Coefficients(h);
    cs_f_FF := [res_mp(el) : el in cs_f];
    cs_h_FF := [res_mp(el) : el in cs_h];
    //f_FF := &+[cs_f_FF[i]*u^(i-1) : i in [1..#cs_f_FF]];
    f_FF := RFF!0;
    for i := 1 to #cs_f_FF do
      f_FF +:= cs_f_FF[i]*u^(i-1);
    end for;
    h_FF := RFF!0;
    for i := 1 to #cs_h_FF do
      h_FF +:= cs_h_FF[i]*u^(i-1);
    end for;
    //h_FF := &+[cs_h_FF[i]*u^(i-1) : i in [1..#cs_h_FF]];
    X_FF := HyperellipticCurve([f_FF, h_FF]);
  else
    X_FF := Reduction(X, P);
    X_FF := Curve(X_FF);
  end if;
  KX_FF := FunctionField(X_FF);
  AX := CoordinateRing(X);
  N_gens := #GeneratorsSequence(AX) - 1; // number of generators for the function field
  KX_gens := [];
  KX_FF_gens := [];
  for i := 1 to N_gens do
    Append(~KX_gens, KX.i);
    Append(~KX_FF_gens, KX_FF.i);
  end for;

  // reduce map
  num_cs, num_mons := CoefficientsAndMonomials(Numerator(phi));
  num_pows := [Exponents(el) : el in num_mons];
  den_cs, den_mons := CoefficientsAndMonomials(Denominator(phi));
  den_pows := [Exponents(el) : el in den_mons];
  phi_FF_num := KX_FF!0;
  for i := 1 to #num_cs do
    phi_FF_num +:= res_mp(num_cs[i])*&*[KX_FF.j^num_pows[i][j] : j in [1..N_gens]];
  end for;
  phi_FF_den := KX_FF!0;
  for i := 1 to #den_cs do
    phi_FF_den +:= res_mp(den_cs[i])*&*[KX_FF.j^den_pows[i][j] : j in [1..N_gens]];
  end for;
  return X_FF, phi_FF_num/phi_FF_den;
end intrinsic;

// copied from endomorphisms b/c EquationOrder is causing problems

function ReduceConstantSplit(x, h)
  return h(x);
end function;

function ReducePolynomialSplit(f, h)
  FF := Codomain(h); R_red := PolynomialRing(FF, Rank(Parent(f)));
  f_red := &+[ ReduceConstantSplit(MonomialCoefficient(f, mon), h) * Monomial(R_red, Exponents(mon)) : mon in Monomials(f) ];
  // Magma subtlety: we have to coerce to a univariate polynomial ring instead of
  // a multivariate ring in one variable
  if Rank(Parent(f)) eq 1 then
      return PolynomialRing(FF) ! f_red;
  end if;
  return f_red;
end function;

function RandomSplitPrime(f, B)
  /*
   * Input:  A polynomial f over K and a positive integer B
   * Output: A totally split prime in K of size roughly 2^B
   *         that stays totally split in the extension generated by f
   */

  K := BaseRing(Parent(f));
  OK := Integers(K);

  while true do
      repeat p := RandomPrime(B : Proof := false); until p^2 ge B;
      FF := FiniteField(p);

      if Type(K) eq FldRat then
          test := true; rt := 1;
      else
          test, rt := HasRoot(MinimalPolynomial(K.1, Rationals()), FF);
      end if;

      if test then
          pr := ideal<OK | [ p, (OK ! K.1) - (OK ! (Integers() ! rt)) ]>;
          /* This calculation costs quite some time */
          FF, h := ResidueClassField(pr);
          f_red := ReducePolynomialSplit(f, h);
          /* We demand full splitting because in the end we have to work with all
           * branches while iterating, and that is better over a prime field */
          if #Roots(f_red) eq Degree(f_red) then
              return pr, h;
          end if;
      end if;
  end while;
end function;

intrinsic PrimeForReduction(phi::FldFunFracSchElt, xs : PrimeBound := 0) -> Any
  {Get prime of size 2^PrimeBound of the base field of parent of phi that doesn't divide any denominators.}

  KX := Parent(phi);
  X := Curve(KX);
  K := BaseRing(X);
  OK := Integers(K);
  R<t> := PolynomialRing(K);
  if PrimeBound eq 0 then
    PrimeBound := 32;
  end if;

  P := RandomSplitPrime(t,PrimeBound);
  // check that P doesn't divide denominators
  dens := [];
  for fcn in xs cat [phi] do
    for el in Coefficients(Numerator(fcn)) do
      Append(~dens, Denominator(el));
    end for;
    for el in Coefficients(Denominator(fcn)) do
      Append(~dens, Denominator(el));
    end for;
  end for;
  I := ideal< OK | dens >;
  assert P + I eq 1*OK;
  return P;
end intrinsic;

intrinsic SortSmallFunctions(phi::FldFunFracSchElt, xs::SeqEnum : Prime := 0, PrimeBound := 0, effort := 6*#xs) -> SeqEnum
  {Given a list xs of functions, compute the size of the monomial support of the resulting curve mod a prime. Return the list of functions sorted by this size.}

  if #xs eq 0 then
   return [];
  end if;
  d_phi:=Degree(phi);
  KX := Parent(phi);
  X := Curve(KX);
  if PrimeBound eq 0 then
    PrimeBound := 32;
  end if;
  if Prime eq 0 then
    P := PrimeForReduction(phi, xs : PrimeBound := PrimeBound);
  else
    P := Prime;
  end if;
  //printf "prime used P = %o\n", P;

  // reduce small functions by P
  X_FF, phi_FF := ReduceRationalFunction(X, phi, P);
  xs_FF := [];
  _, x_FF := ReduceRationalFunction(X, xs[1], P);
  Append(~xs_FF, x_FF);
  KX_FF1 := Parent(xs_FF[1]);
  //for el in xs do
  for i := 2 to #xs do
    el := xs[i];
    _, x_FF := ReduceRationalFunction(X, el, P);
    KX_FF := Parent(x_FF);

    // if Genus(X) eq 0 then   JV: not genus zero, we mean only one generator of function field
    // and those are not the same, since we might have the function field given as
    // generated by two elements (even though this isn't optimal)
    try
      iso_x := hom< KX_FF -> KX_FF1 | [KX_FF1.1, KX_FF1.2]>;
    catch e
      iso_x := hom< KX_FF -> KX_FF1 | [KX_FF1.1]>;
    end try;
    Append(~xs_FF, iso_x(x_FF));
  end for;
  Nmons := [];
  ts_xs_Fs := [];
  for i := 1 to #xs do
    x_op := xs[i];
    x_op_FF := xs_FF[i];
    //print "computing model over finite field";
    F_res_FF := PlaneModel(phi_FF, x_op_FF);
    // S3 Orbit
    F_orb := S3Orbit(F_res_FF);
    phi_orb := S3Orbit(phi); // import from Belyi
    for i := 1 to #F_orb do
        t := phi_orb[i];
        F := F_orb[i];
        mons_FF := Monomials(F);
        Append(~Nmons, [#mons_FF, Degree(x_op_FF)]);
        Append(~ts_xs_Fs, [* t, x_op, F *]);
    end for;
    // printf "%o monomials, max degree = %o\n", #mons_FF, Max([Degree(el) : el in mons_FF]);
  end for;
  ts_xs_Fs_sorted := ts_xs_Fs;
  ParallelSort(~Nmons, ~ts_xs_Fs_sorted);
  // check that genus is correct, throw out otherwise
  g := Genus(X);
  m := 1;
  while m le #ts_xs_Fs_sorted and m le effort do
    tm, xm, Fm := Explode(ts_xs_Fs_sorted[m]);
    C_m := Curve(AffineSpace(Parent(Fm)), Fm);
    if Genus(C_m) eq g and Degree(Fm,Parent(Fm).2) eq Degree(phi) then
      m +:= 1;
    else
      Remove(~ts_xs_Fs_sorted, m);
    end if;
  end while;
  return ts_xs_Fs_sorted[1..Min(effort,#ts_xs_Fs_sorted)];
end intrinsic;
